[ { "title": "Как актуализировать изменения в общих модулях без pull request.", "url": "/posts/common-branch-exchange/", "categories": "Git", "tags": "Git", "date": "2022-09-14 17:35:00 +0300", "snippet": "Проблема разработки с общим CommonUIОсвежим общий процесс разработки. Создаем задачу в Projects на GitHub Зная номер задачи создаем ветку feature/X, где X - номер задачи Разрабатываем, делая N комитов Когда задача завершена - делаем pull request Жмем кнопку и сливаем эти изменения в master.Данная схема имеет смысл только когда напрямую в master комитить нельзя. Так у нас и настроено, чтобы этот flow нельзябыло обойти.Разработка фичи происходит какое-то время - несколько дней, неделю. И как можно заключить из вышеуказанного алгоритмаразработки - pull request делается в общем один раз на фичу. Т.е. мы фичу разрабатываем в изоляции от master ветки.Что делать, если кто-то залил свои изменения в master ? Казалось бы залил и залил. Но при pull request возникнетошибка, и git заставит сначала выкачать новые изменения из master. Поэтому рекомендуется как можно чаще обновлять своюфича ветку из мастера, это избавит от проблем при pull request.Здесь видим, что master появились чужие изменения. Поэтому чтобы привести свою фича веткуdevelop в актуальное состояние выполняем команду:$ git checkout master$ git rebase develop masterПосле чего все встает на свои места:Проблема обмена изменениями в Common модуляхОпишем следующую проблему в разработке. Допустим два разработчика разрабатывают 2 разные фичи и их изменения непересекаются. Но пересечения все-таки скорее всего произойдут в общим модулях, таких как - Common или CommonUI. Инымисловами, когда я разрабатываю экран, возможно я создам какой-то красивый UI элемент, который все могут переиспользовать.Но они не смогут им воспользоваться, пока разработчик не закончит разработку всей фичи и не зальет ее в master. А это,как уже говорилось, может произойти через несколько дней, а то и через неделю.Как можно решить эту проблему ? Первый способ который напрашивается - вынести изменения в CommonUI и Common какотдельные задачи. Тогда и pull request по ним будет оправдан. Но все же, как я считаю, это плохой вариант, мы никогда незнаем когда захотим поправить common компонент, т.е. эти изменения сложно спланировать. И если делать на каждыйнебольшой чих pull request - это приведет к замедлению разработки и большому количеству лишних действий.Другой способ, как я считаю, более оптимальный - иметь отдельную ветки для common и commonUI через которые фича веткибудут обмениваться последними изменениями в commonUI не прибегая к ветке master.Посмотрим на примере. Создадим фейковый проект, с простой структурой папок..├── Common│ └── SomeCode.swift├── Feature1│ └── Feature1Source.swift├── Feature2│ └── Feature2Source.swift└── Read.MEДопустим я нахожусь в ветке feature/1 и произвел изменения в файлах Feature1Source.swift и SomeCode.swift. Т.е.Часть изменения касается непосредственно моей фичи, а другая общего модуля Common.Теперь я хочу чтобы мои изменения в Common были доступны другим разработчикам, но саму фичу я еще продолжаюразрабатывать и не хочу еще делать pull request. Для этого я делаю комит своих изменений в Common. Здесь очень ВАЖНО!сделать кормит только изменения в папке Common.Проэмулируем работу с файлами через консоль:# изменения в файле Feature1/Feature1Source.swift$ echo \"some feature1 code\" &gt;&gt; Feature1/Feature1Source.swift# изменения в файле SomeCode.swift$ echo \"some common code\" &gt;&gt; Common/SomeCode.swift# убедиться что в файлах изменения добавились можно командой$ cat Feature1/Feature1Source.swift# в результате выведется:some feature1 codeДалее делаем кормит изменений только в папке Common$ git add -- ./Common$ git commit -m 'My changes to Common' -- ./Common# в результате выведется:[feature/1 (root-commit) 4e1d4b0] My changes to Common1 file changed, 1 insertion(+)create mode 100644 Common/SomeCode.swiftОтлично, мы видим что в комит попали только изменения SomeCode.swift, что нам и нужно было.Далее необходимо закомитить все остальные изменения по фиче:$ git add .$ git commit -m “Feature 1 changes”Ура! Все наши изменения закомичены.Далее необходимо сделать небольшое отступление и объяснить что такое cherry pick.Cherry pickЕсли простыми словами - cherry pick это способность взять отдельный комит и скопировать его в другую ветку. А это как разто, что нам нужно - взять изменения модуля Common и перенести их в общую ветку для обмена ими в обход master ветки.Посмотрим как работает cherry-pick схематично. Допустим у нас есть две ветки:a - b - c - d Main \\ e - f - g FeatureИ мы хотим кормит f перенести в ветку Main. Тогда выполняем две команды$ git checkout main$ git cherry-pick fВ результате получаем следующую картину:a - b - c - d - f Main \\ e - f - g FeatureПрименение cherry pick на практике.Сольём только Common изменения в ветку common.Вернемся к нашему проекту. Первое что нам нужно - это узнать sha код комита, который мы сделали из папки Common. Дляэтого выполняем команду:$ git logПолучаем приблизительно такой результат:commit abae47d4524651fea4c08bf47393963a0a1dde47 (HEAD -&gt; feature/1)Author: Sergio &lt;afirthes@gmail.com&gt;Date: Wed Sep 14 21:17:23 2022 +0300 Feature 1 changescommit 4e1d4b0a91cea71aaac23839db4443133c20ab5a (common)Author: Sergio &lt;afirthes@gmail.com&gt;Date: Wed Sep 14 21:01:01 2022 +0300 My changes to CommonТам может быть много записей, нас интересует именно наш комит по Common. Для его поиска можно ориентироваться наветку feature/1 и комментарий комита.Далее запоминаем sha комита - 4e1d4b0a91cea71aaac23839db4443133c20ab5a. На самом деле достаточно запомнить первыенесколько символов, вероятность что они повторяются довольно мала.И делаем следующее:$ git checkout common$ git cherry-pick 4e1d4b0Если все прошло успешно - с помощью git log - мы увидем в списке наш коммит с соотвествующим кодом. Задача выполнена -мы слили в ветку common все изменения касающиеся папки Common, а все другие изменения оставили в feature/1 ветке.Осталось только разобраться как забирать в свою фича ветку изменения из common ветки.Подтягивание в свою ветку изменений из common.Итак, допустим я разрабатываю фичу 2 в ветке feature/2 и мне нужно подгрузиь изменения из common. Тогда делаюпросто:$ git checkout feature/2$ git rebase feature/2 commonВсё. Мы подтянули изменения в папке Common из ветки feature/1 в ветку feature/2, используя промежуточную веткуcommon. Теперь я могу использовать общие компоненты своего коллеги, даже несмотря на то, что их пока нет в master. Не забываем что ветки нужно как можно чаще push-ить на сервер.Примерно схему такой работы можно показать так:" }, { "title": "Зачем нужны сервисы и как их готовить", "url": "/posts/understand-services-concept/", "categories": "Architecture, Getting Started", "tags": "Services", "date": "2022-09-10 15:45:00 +0300", "snippet": "Без сервисов Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим программнымобеспечением для его улучшения, например, для удаления «дурно пахнущего кода».В какой-то момент при написании проекта в коде начинает появляться повторяющийся код.class ClassA { func foo1() { // загрузка данных из бд // изменение объекта в соотвествии с бизнес логикой // сохранение изменений в бд // вызов rest сервера } func foo1() { // загрузка данных из бд // создание записи в бд // сохранение изменений в бд // вызов rest сервера }}Конечно, программисту знакомому с принципами SOLID сразу не понравится этот код. Но наберемся терпения и пойдем шаг зашагом. Первое, что мы можем сделать, это начать выносить переиспользуемый код в функции.class ClassA { func saveToDB() { // сохранение изменений в бд } func getFromDB() { // загрузка данных из бд } func makeChange() { // изменение объекта в соотвествии с бизнес логикой } func callUrl() { // вызов rest сервера } func foo1() { getFromDB() makeChange() saveToDB() callUrl() } func foo1() { getFromDB() makeChange() saveToDB() callUrl() }}Уже лучше, мы минимизировали повторения кода. Однако, как в первом так и во втором случае мы нарушаем принципы SOLID.Самым явным в данном случае является Single Responsibility. Т.е. у нашего класса очень много функций - и в базузаписи положи, и сделай изменения в классе, и коммуникацию с сервером осуществи. Но не время отчаиваться, далее мыпостепенно это исправим. Попробуй обосновать какие принципы SOLID здесь нарушеныДалее разрабатывая проект, мы обнаруживаем, что у нас появляются другие классы со схожими функциями, где-то их полностьюкопируем, где-то модифицируем. Помни, если тебе приходится размножать код в проекте методом копирования - нужно остановиться, задуматься и вспомнитьпринцип DRY - Dont Repeat YourselfМы помним что копирование плохо. Но что мы можем сделать. Самое простое - взять и сделать один класс, куда помещатьвсе наши очень полезные функции. Отлично, теперь нам не нужно копировать код, все кому нужен функционал - можетобратиться к нашему классу, назовем его MegaUtil. Хммм… не покидает чувство, что здесь что-то не так ? Сможешь сказать почему копирование кода это плохо ?Да, в общем то, мы проблему из одного места перенесли в другое - наш новый класс так же делает все чтотолько можно - с базой взаимодействует, реализует бизнес логику, осуществляет rest вызовы.class MegaUtil { func saveToDB() { // сохранение изменений в бд } func getFromDB() { // загрузка данных из бд } func makeChange() { // изменение объекта в соотвествии с бизнес логикой } func callUrl() { // вызов rest сервера }}Перечисляя назначения этого класса я на самом деле перечисляю доменные области данного класса. Здесь можновыделить их три: Работа с БД Бизнес логика Взаимодествие с серверомИ получается, чтобы не нарушать Single Responsibility - нам достаточно вместо одного класса создать 3class DatabaseService { func saveToDB() { // сохранение изменений в бд } func getFromDB() { // загрузка данных из бд }}class BusinessLogicService { func makeChange() { // изменение объекта в соотвествии с бизнес логикой }}class NetworkService { func callUrl() { // вызов rest сервера }}Как видно мы используем постфикс Service в конце названия классов. Это потому, что они уже более стали походить наполноценные сервисы. Но чего еще не хватает ?Использование протоколовРаботая с проектом, возможно, произойдет ситуация когда нам прийдется поменять базу данных, напирмер с Ralmперейти на Core Data. Да, такое очень маловероятно. Но можно придумать и другие примеры, например, вместосохранения картинки на сервере - необходимо будет сохранять ее на устройстве.Нам очень бы хотелось “обезопасить”свой код от таких изменений, а именно, чтобы когда сервис менялся - нам не приходилось бы делать соотвествующиеизменения по всем файлам проекта, это очень трудоемко и ведет к ошибкам и багам.Этого можно добиться, начав рассматривать сервисы как некий черный ящик с набором методов. Т.е. когдапредоставляют какой-то сервис - нам не интересно как он реализован, нам вполне достаточно знатьчто мы можем вызвать нужные нам методы. Такое отношение к сервисам, как к черным ящикам, ведет к интересномуэффекту, который называется loose coupling, т.е. ослаблению связанности частей проекта между собой.Осталось только понять, как заставить сервис реализовывать нужные нам методы. Такая гарантия еще называетсяконтрактом. В языке swift для этого есть конкретная конструкция под названием protocol.Посмотрим как с помощью нее мы можем создать контрак для сервиса работы с базой данных. Добавим еще аргументовфункциям, чтобы было более наглядно.protocol DatabaseService { func saveToDB(someArg: String) func getFromDB() -&gt; Image}Как видим все довольно просто. Нужно придумать название контракту, которому будут соответствовать описываемые сервисы DatabaseService. Перечислить методы, которые должны в нем быть. Готово! Теперь мы можем создавая сервис, указывать, что он реализует протокол.protocol RealmDatabaseService: DatabaseService { func saveToDB(someArg: String) { // код для сохранения в Realm базу данных } func getFromDB() -&gt; Image { // код для получения картинки из Realm базы данных }}Далее можем сделать другую реализацию для Core Data:protocol CoreDataDatabaseService: DatabaseService { func saveToDB(someArg: String) { // код для сохранения в CoreData базу данных } func getFromDB() -&gt; Image { // код для получения картинки из CoreData базы данных }}Самое интересно, что мы можем сделать сервис-заглушку, которая никуда не будет обращаться и возвращатьзаранее определенные значения. Это может быть полезно для тестов. Так же, при использовании tuist,когда разработка ведется над какими-то модулями, например, UI, где не требуется реально подключениек базе данных, а нужна какая-та заглушка, чтобы компонент функционировал и можно было бы спокойноего разрабатывать с точки зрения верстки. Обычно такие сервисы называются Mock:protocol MockDatabaseService: DatabaseService { func saveToDB(someArg: String) { // здесь ничего не сохраняется. Просто позволяем вызвать этот пустой метод. } func getFromDB() -&gt; Image { // здесь всегда возвращаемся заранее подготовленную картинку. return Image(named: \"dummy\") }}Что дальшеДелая заглушки для тестов и для разработки отдельных модулей - очень полезная вещь. Но все же этот подход неидеален - какая-то часть кода все равно должна знать как собирать сервисы. Т.е. получается что есть части кода, которые друг о друге ничего не знают, но нам не обойтись от части кода, который будет знать всё обо всех. Иначенаш код просто не заработает - нужен код, который будет скливать между собой сервисы.Процесс связывания сервисов между собой называется Dependency Injection. Принцип работы связывания довольно прост -мы регистрируем свою реализацию сервиса. А другие сервисы, зная только протокол, обращаются к регистратору за этимсервисом. Этот сервис им предоставляется, но они не знаю конкретной реализации, знают только что этотсервис точно реализует нужные им функции.Эта тема будет раскрыта в следующих статьях." } ]
